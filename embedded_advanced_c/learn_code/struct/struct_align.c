#include<stdio.h>

/*
为什么需要内存对齐？
内存对齐可以大大提升内存访问速度，是一种用空间换时间的方法。
内存不对齐会导致每次读取数据都会读取两次，使得内存读取速度减慢。

为什么内存不对齐会影响读取速度？
假设CPU要读取一个4字节大小的数据到寄存器中（假设每次读4四字节），分两种情况讨论：
1.数据从0地址开始（内存对齐）2.数据从1地址开始（内存不对齐）

解析：当数据从0地址开始的时候，直接将0-3四个字节完全读取到寄存器，结算完成了（一遍即可）。
当数据从1地址开始的时候，问题很复杂，首先先将前4个字节读到寄存器，并再次读取4-7字节的
数据进寄存器，接着把0字节，4,6,7字节的数据剔除，最后合并1,2,3,4字节的数据进寄存器，
对一个内存未对齐的寄存器进行了这么多额外操作，大大降低了CPU的性能。
但是这还属于乐观情况，内存对齐的作用之一是平台的移植原因，因为只有部分CPU能解析内存不对齐，
其他部分CPU遇到未对齐边界就直接罢工了。
*/

/*
结构体对齐原则：
1、结构体首地址按最大类型字节数对齐
2、每个成员的首地址是自身大小的整数倍
3、结构体的总大小，为其成员中所含最大类型的整数倍
*/


/*
程序功能描述：分析结构体对齐
*/

struct STRU1{ 
	char a;		
	int b;		
	short c;    
}; 
//最大类型int，结构体4字节对齐
//a =  4 b = 4 c = 4
//结构体总长为 12

struct STRU2{ 
	short a;    
	char b;    
	int c;      
};		
//最大类型int，结构体4字节对齐
//a = 2 b = 2 c = 4
//结构体总长为 8
struct STRU3{ 
	short a;    
	double b;   
	int c;      
};				
//最大类型int，结构体8字节对齐
//a = 8 b =8 c = 8
//结构体总长为 24 

int main(void)
{
	printf("STRU1 = %ld\n",sizeof(struct STRU1));
	printf("STRU2 = %ld\n",sizeof(struct STRU2));
	printf("STRU3 = %ld\n",sizeof(struct STRU3));
	return 0;
}


